@node Completely Fair Scheduler
@appendix Completely Fair Scheduler

@iftex
@macro tm{TEX}
@math{\TEX\}
@end macro
@macro nm{TXT}
@end macro
@macro am{TEX, TXT}
@math{\TEX\}
@end macro
@end iftex

@ifnottex
@macro tm{TEX}
@end macro
@macro nm{TXT}
@w{\TXT\}
@end macro
@macro am{TEX, TXT}
@w{\TXT\}
@end macro
@end ifnottex

@ifhtml
@macro math{TXT}
\TXT\
@end macro
@end ifhtml

@macro m{MATH}
@am{\MATH\, \MATH\}
@end macro

For project 1, you must implement the scheduler described in this appendix. This scheduler is a simplified version of the Completely Fair Scheduler (@acronym{CFS}) in Linux. 

@menu
* Thread Niceness::             
* Thread Weight::        
* Thread Vruntime::      
* Thread Ideal Runtime::  
* Sleeper Threads::      
* CFS Scheduler Summary::     
* Load Balancing::
@end menu

@node Thread Niceness
@section Niceness

Each thread has an integer @var{nice} value that determines how "nice" the thread should be to other threads. A positive @var{nice}, to the maximum of @w{@var{NICE_MAX} (19)}, decreases the priority of a thread and causes it to give up some CPU time it would otherwise receive. On the other hand, a negative @var{nice}, to the minimum of @var{NICE_MIN} (-20), tends to take away CPU time from other threads. By default, each thread has a @var{nice} value of @var{NICE_DEFAULT} (0). Nice values are used to assign weights to each thread

You must implement the functions described below, which are for
use by test programs.  We have provided skeleton definitions for them in
@file{threads/thread.c}.

@deftypefun int thread_get_nice (void)
Returns the current thread's @var{nice} value.
@end deftypefun

@deftypefun void thread_set_nice (int @var{new_nice})
Sets the current thread's @var{nice} value to @var{new_nice}.
@end deftypefun

@node Thread Weight
@section Weight

Each thread has a integer weight that is assigned based solely on its @var{nice} value. Threads with lower @var{nice} values have more priority, and therefore have higher weight. In contrast, threads with higher @var{nice} values have lower weight. The weight of each thread is directly involved when making scheduling decisions. In general, threads with higher weights tend to not only be scheduled more often, but run for longer periods of time when scheduled.

Here are the mappings from nice to weight.

@group
static const uint32_t prio_to_weight[40] =@*
@	 @	 @{@*
@	 @	 @	 @	/* -20 */     @	 88761, 71755, 56483, 46273, 36291,@*
@	 @	 @	 @	/* -15 */     @	 29154, 23254, 18705, 14949, 11916,@*
@	 @	 @	 @	/* -10 */     @	 9548, 7620, 6100, 4904, 3906,@* 
@	 @	 @	 @	/* @ @ -5 */  @	 3121, 2501, 1991, 1586, 1277,@*
@	 @	 @	 @	/* @ @ @ 0 */ @	 1024, 820, 655, 526, 423,@*
@	 @	 @	 @	/* @ @ @ 5 */ @	 335, 272, 215, 172, 137,@*
@	 @	 @	 @	/* @ 10 */    @	 110, 87, 70, 56, 45,@*
@	 @	 @	 @	/* @ 15 */    @	 36, 29, 23, 18, 15,@*
@	 @	 @};@*
@end group 

@node Thread Vruntime
@section Calculating @var{vruntime}

Each thread keeps track of its @var{vruntime}. Vruntime stands for "virtual runtime." It is a weighted measurement of how much time a thread has run on the CPU. @acronym{CFS} wants to be fair to all threads. Therefore, when picking a task to run, the thread with the lowest @var{vruntime} clearly deserves to run and is therefore selected. If multiple threads have the same @var{vruntime}, choose the one with lowest tid. When updating @var{vruntime}, the weight of the thread is taken into account. Given the same amount of cpu runtime, @var{vruntime} increases more slowly for a thread with higher weight and more quickly for a thread with lower weight. 

The initial thread's @var{vruntime} is initialized to 0. When a new thread is created, it's @var{vruntime} is initialized to @var{min_vruntime}, which is the @var{vruntime} of the thread with the lowest @var{vruntime} that is either ready or running. Afterwards, it is incremented periodically based on its runtime and its weight. 

@center @var{vruntime} += @var{d} * @var{w0} / @var{w}

@noindent where @var{d} is the amount of wall-clock time the thread has run since a thread's @var{vruntime} was last updated, @var{w0} is the weight of a thread with 0 @var{nice}, and @var{w} is the weight of the thread.

Notice that in the common case where all threads have the same weight, s = @var{n} * @var{w}, and therefore the ideal runtime is 4000000

A question that arises is when to update the @var{vruntime} of a thread. Clearly, there is no need to update the @var{vruntime} of a thread that is on the ready queue or sleep queue, since they do not get runtime. The currently running thread's @var{vruntime} must be updated when the scheduler makes important decisions, such as selecting a task to run and calculating @var{min_vruntime}. Otherwise, the scheduler can choose to delay updating @var{vruntime} to only when it is necessary. 

@node Thread Ideal Runtime
@section Calculating @var{ideal_runtime}

At each timer interrupt, the scheduler has to make an important decision. That is: should it let the current thread continue running, or let someone else run? If it always decides to let someone else run, then threads will be scheduled more frequently and run for short periods, incurring high scheduling overhead. On the other hand, if the scheduler consistently refuses to preempt the current thread, then the overall effect is that threads do not get picked to run very often, but once picked they run for a long time, causing slow perceived response time. 

In @acronym{CFS}, threads run for some time before they are preempted. That amount of time is called the @var{ideal_runtime}, and it is different for each thread, depending on that thread's weight relative to the weight of the other threads.

@center @var{ideal_runtime} = 4000000 * @var{n} * @var{w} / s

@noindent where @var{n} is the number of threads either running or ready to run, @var{w} is the weight of the currently running thread, and s is the sum of weights of all threads that are either running or ready to run.

Notice that in the common case where all threads have the same weight (s = @var{n} * @var{w}), the ideal runtime is 4000000

@node Sleeper Threads
@section Sleeper threads

Some threads are I/O bound and spend much of their time in the blocked state. We refer them as "sleepers." 

When a thread is unblocked, its @var{vruntime} is likely to be lower than other threads that did not sleep. Therefore, it will be repeatedly scheduled (aka "hog the CPU") until its @var{vruntime} has caught up with the other threads. To avoid this, @acronym{CFS} sets its @var{vruntime} to be @var{min_vruntime}. However, we also want to give sleepers a small "sleeper bonus." After all, it spent a lot being ignored by the scheduler because it was not on the ready queue. Therefore, we give it a "sleeper bonus" of 20000000. However, this could potentially cause a short sleeper to "gain" time by intentionally sleeping for a short amount of time and taking advantage of the sleeper bonus. Therefore we make sure that its new @var{vruntime} is strictly greater or equal to its previous @var{vruntime} - the @var{vruntime} it had when it went to sleep.

@center @var{sleeper_vruntime} = max(@var{sleeper_prev_vruntime}, @var{min_vruntime} - 20000000)

@node CFS Scheduler Summary
@section Summary
@acronym{CFS} can be summarized by the following: At each timer tick, preempt the current thread if it ran for @var{ideal_runtime} or longer. When choosing which thread to run next, pick the thread with lowest @var{vruntime}. Break ties by choosing lowest tid. 


Let @var{d} be the amount of wall-clock time elapsed since a thread's @var{vruntime} was last updated, @var{w0} be the weight of a thread with 0 @var{nice}, and @var{w} be the weight of the thread. Then:

@center @var{vruntime} += @var{d} * @var{w0} / @var{w}

Let @var{n} be the number of threads either running or ready to run, @var{w} be the weight of the currently running thread, and s be the sum of weights of all threads that are either running or ready to run. Then:

@center @var{ideal_runtime} = 4000000 * @var{n} * @var{w} / s

When a thread is unblocked for the first time, its @var{vruntime} is:

@center @var{initial_vruntime} = @var{min_vruntime}

When a thread is unblocked after going to sleep, its @var{vruntime} is:

@center @var{sleeper_vruntime} = max(@var{sleeper_prev_vruntime}, @var{min_vruntime} - 20000000)

@node Load Balancing
@section Load Balancing

While the previous sections focused on the per-processor scheduling policy, this section
focuses on the how CFS balances the load between two CPUs.
This load balancing policy is specific towards the CFS scheduler. Thus we recommend that 
you get CFS working before attempting to implement a load balancer. The only part your 
load balancer will not need working is sleeper threads.

When a CPU wants to pull threads from another CPU, CFS examines the @var{load} on each CPU. 
@var{Load} is the sum of weights of all threads in the ready queue (notice that 
unlike previous definitions, the weight of the running thread is not taken into account
here). An @var{imbalance} is calculated as follows:

@center @var{imbalance} = (@var{busiest_load - my_load}) / 2

@noindent where busiest_load is the @var{load} of the CPU with highest load and my_load is the
@var{load} of the CPU that initiated the load balancing. 

If @var{imbalance} is small (@var{imbalance} * 4 < @var{busiest_load}) 
then no rebalancing occurs. 
Otherwise,  CFS pulls threads from the busiest CPU to the CPU that initiated the load balancing.
It continues to do so until @var{load_moved}, defined as the sum of weights of threads that 
have been migrated, equals or exceeds @var{imbalance}.

The @var{vruntime} of the threads between the two CPUs can be vastly different. A thread's @var{vruntime} is only significant when compared to the @var{vruntime} of other threads on its local queue.
Therefore, @var{vruntime} on each of the migrated threads are adjusted as follows:

@center @var{new_vruntime} = @var{old_vruntime} - @var{busiest_minvruntime} + @var{my_vruntime}

@noindent where @var{old_vruntime} is the thread's original vruntime, @var{busiest_minvruntime} is the @var{minvruntime} of the busiest CPU and @var{my_minvruntime} is the @var{minvruntime} of the CPU that initiated the load balancing. 

@html
</CENTER>
@end html
