
- Spinlock - why does it need both 'locked' and 'cpu'?  The comment says
  they are kept in sync.  Why can't you atomically swap in the cpu into &cpu?
  Spinlocks are frequent - every byte matters in terms of size.

  Yes, we don't need both. Great catch. It doesnt need to be atomic its protected
  by the spinlock itself

- In thread.c, what's this TODO for?

//  TODO: ASSERT (t->cpu == get_cpu ());
  
  This assertion should always be true under normal circumstances. I can't use it
  because the scheduling driver changes get_cpu () to the fake CPU but leaves
  t->cpu untouched (t is the thread that is running the driver). The other option is
  to change t->cpu to the fake cpu and switch it back after, which I'm okay with.
  //REPLY

- In thread_set_nice, what protects 'nice' (or should the update be atomic?)

  Threads can only get and set their own nice value, which means that no two 
  CPUs will ever try to read at the same time. Reading it acquires a spinlock
  which would issue a barrier. (Plus I really can't see how a compiler or
  hardware can ever interleave the two)

  -> Well in Unix I can change the nice value of another process, but you're right,
  in Pintos you can't.

- Note that code like

    intr_disable_push();
    printf ();

 from outside an interrupt context is not legal unless the
 console has been put in EMERGENCY_MODE.

 This is because otherwise the assertion in schedule that ncli == 1
 fails (which allows for exactly one call to intr_disable_push,
 or indirectly via  spinlock_acquire).

 We need to better comment this assertion.  It's intended
 to detect when more than one spinlock is mistakenly held when calling
 schedule.  Can cpu->ncli be > 1 for other reasons and it is ok to
 call schedule?

 I would not make the case for above scenario, that is, I would panic
 there. But I'm not sure about all cases yet.
